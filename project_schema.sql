-- Project Specific Scripts (Public Schema)

-- Functions

CREATE FUNCTION public.handle_new_user() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

begin

  insert into public.profiles (id, full_name, email, role, status)

  values (

    new.id, 

    new.raw_user_meta_data->>'full_name', 

    new.email, 

    'customer', 

    'active'

  );

  return new;

end;

$$;


ALTER FUNCTION public.handle_new_user() OWNER TO postgres;

CREATE FUNCTION public.is_admin() RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

begin

  return exists (

    select 1 from public.profiles

    where id = auth.uid() and role = 'admin'

  );

end;

$$;


ALTER FUNCTION public.is_admin() OWNER TO postgres;

CREATE FUNCTION public.update_product_rating() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$

begin

  update public.products

  set rating_avg = (

      select coalesce(avg(rating), 0)::numeric(2,1)

      from public.reviews 

      where product_id = coalesce(new.product_id, old.product_id) 

      and is_approved = true

  ),

  rating_count = (

      select count(*) 

      from public.reviews 

      where product_id = coalesce(new.product_id, old.product_id) 

      and is_approved = true

  )

  where id = coalesce(new.product_id, old.product_id);



  return new;

end;

$$;


ALTER FUNCTION public.update_product_rating() OWNER TO postgres;    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    full_name text,
    address_line1 text NOT NULL,
    address_line2 text,
    city text NOT NULL,
    state text NOT NULL,
    postal_code text NOT NULL,
    country text NOT NULL,
    is_default boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


ALTER TABLE public.addresses OWNER TO postgres;

--
-- Name: attributes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.attributes (
    id bigint NOT NULL,
    name text NOT NULL,
    type text NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT attributes_type_check CHECK ((type = ANY (ARRAY['text'::text, 'number'::text, 'select'::text, 'color'::text])))
);


ALTER TABLE public.attributes OWNER TO postgres;

--
-- Name: attributes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.attributes ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.attributes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: cart_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cart_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    product_id bigint NOT NULL,
    variant_id bigint,
    quantity integer DEFAULT 1 NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


ALTER TABLE public.cart_items OWNER TO postgres;

--
-- Name: categories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.categories (
    id bigint NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    image_url text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    parent_id bigint
);


ALTER TABLE public.categories OWNER TO postgres;

--
-- Name: categories_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.categories ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.categories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: order_items; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.order_items (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    order_id uuid NOT NULL,
    product_id bigint,
    variant_id bigint,
    quantity integer NOT NULL,
    price numeric NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


ALTER TABLE public.order_items OWNER TO postgres;

--
-- Name: orders; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.orders (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    status text NOT NULL,
    total_amount numeric NOT NULL,
    currency text DEFAULT 'INR'::text,
    razorpay_order_id text,
    razorpay_payment_id text,
    razorpay_signature text,
    shipping_address jsonb,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT orders_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'paid'::text, 'failed'::text])))
);


ALTER TABLE public.orders OWNER TO postgres;

--
-- Name: product_variant_attributes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_variant_attributes (
    id bigint NOT NULL,
    variant_id bigint NOT NULL,
    attribute_id bigint NOT NULL,
    value text NOT NULL
);


ALTER TABLE public.product_variant_attributes OWNER TO postgres;

--
-- Name: product_variant_attributes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.product_variant_attributes ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.product_variant_attributes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: product_variants; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_variants (
    id bigint NOT NULL,
    product_id bigint NOT NULL,
    sku text,
    price numeric NOT NULL,
    stock integer DEFAULT 0 NOT NULL,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    image_url text,
    images text[],
    is_default boolean DEFAULT false
);


ALTER TABLE public.product_variants OWNER TO postgres;

--
-- Name: product_variants_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.product_variants ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.product_variants_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: products; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products (
    id bigint NOT NULL,
    name text NOT NULL,
    slug text NOT NULL,
    description text,
    price numeric DEFAULT '0'::numeric NOT NULL,
    stock integer DEFAULT 0 NOT NULL,
    category_id bigint,
    image_url text,
    images text[],
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    product_type text DEFAULT 'simple'::text,
    rating_avg numeric(2,1) DEFAULT 0.0,
    rating_count integer DEFAULT 0,
    product_code text,
    CONSTRAINT products_product_type_check CHECK ((product_type = ANY (ARRAY['simple'::text, 'variant'::text])))
);


ALTER TABLE public.products OWNER TO postgres;

--
-- Name: products_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.products ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.products_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.profiles (
    id uuid NOT NULL,
    full_name text,
    phone text,
    address text,
    role text DEFAULT 'customer'::text,
    status text DEFAULT 'active'::text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    email text,
    CONSTRAINT profiles_role_check CHECK ((role = ANY (ARRAY['customer'::text, 'admin'::text]))),
    CONSTRAINT profiles_status_check CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text])))
);


ALTER TABLE public.profiles OWNER TO postgres;

--
-- Name: reviews; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reviews (
    id bigint NOT NULL,
    user_id uuid NOT NULL,
    product_id bigint NOT NULL,
    rating integer NOT NULL,
    comment text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    reply_text text,
    replied_at timestamp with time zone,
    title text,
    images text[] DEFAULT ARRAY[]::text[],
    updated_at timestamp with time zone,
    is_approved boolean DEFAULT false,
    CONSTRAINT reviews_rating_check CHECK (((rating >= 1) AND (rating <= 5)))
);


ALTER TABLE public.reviews OWNER TO postgres;

--
-- Name: reviews_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.reviews ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.reviews_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);
--

ALTER TABLE ONLY public.addresses
    ADD CONSTRAINT addresses_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: cart_items cart_items_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cart_items
    ADD CONSTRAINT cart_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE CASCADE;


--
-- Name: cart_items cart_items_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cart_items
    ADD CONSTRAINT cart_items_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: cart_items cart_items_variant_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cart_items
    ADD CONSTRAINT cart_items_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES public.product_variants(id) ON DELETE CASCADE;


--
-- Name: categories categories_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES public.categories(id);


--
-- Name: order_items order_items_order_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_items
    ADD CONSTRAINT order_items_order_id_fkey FOREIGN KEY (order_id) REFERENCES public.orders(id) ON DELETE CASCADE;


--
-- Name: order_items order_items_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_items
    ADD CONSTRAINT order_items_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE SET NULL;


--
-- Name: order_items order_items_variant_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.order_items
    ADD CONSTRAINT order_items_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES public.product_variants(id) ON DELETE SET NULL;


--
-- Name: orders orders_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.orders
    ADD CONSTRAINT orders_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: product_variant_attributes product_variant_attributes_attribute_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_variant_attributes
    ADD CONSTRAINT product_variant_attributes_attribute_id_fkey FOREIGN KEY (attribute_id) REFERENCES public.attributes(id) ON DELETE CASCADE;


--
-- Name: product_variant_attributes product_variant_attributes_variant_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_variant_attributes
    ADD CONSTRAINT product_variant_attributes_variant_id_fkey FOREIGN KEY (variant_id) REFERENCES public.product_variants(id) ON DELETE CASCADE;


--
-- Name: product_variants product_variants_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_variants
    ADD CONSTRAINT product_variants_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE CASCADE;


--
-- Name: products products_category_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id);


--
-- Name: profiles profiles_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: reviews reviews_product_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviews
    ADD CONSTRAINT reviews_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.products(id) ON DELETE CASCADE;


--
-- Name: reviews reviews_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviews
    ADD CONSTRAINT reviews_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;



--
-- Name: attributes Admins can delete attributes; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can delete attributes" ON public.attributes FOR DELETE USING (((auth.jwt() ->> 'email'::text) = 'test@email.com'::text));


--
-- Name: product_variant_attributes Admins can delete variant attributes.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can delete variant attributes." ON public.product_variant_attributes FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: product_variants Admins can delete variants.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can delete variants." ON public.product_variants FOR DELETE USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: attributes Admins can insert attributes.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can insert attributes." ON public.attributes FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: product_variant_attributes Admins can insert variant attributes.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can insert variant attributes." ON public.product_variant_attributes FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: product_variants Admins can insert variants.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can insert variants." ON public.product_variants FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: profiles Admins can update any profile.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update any profile." ON public.profiles FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.profiles profiles_1
  WHERE ((profiles_1.id = auth.uid()) AND (profiles_1.role = 'admin'::text)))));


--
-- Name: reviews Admins can update any review.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update any review." ON public.reviews FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: attributes Admins can update attributes; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update attributes" ON public.attributes FOR UPDATE USING (((auth.jwt() ->> 'email'::text) = 'test@email.com'::text));


--
-- Name: orders Admins can update orders.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update orders." ON public.orders FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: product_variant_attributes Admins can update variant attributes.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update variant attributes." ON public.product_variant_attributes FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: product_variants Admins can update variants.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update variants." ON public.product_variants FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: order_items Admins can view all order items.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all order items." ON public.order_items FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: orders Admins can view all orders.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all orders." ON public.orders FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: reviews Admins can view all reviews.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can view all reviews." ON public.reviews FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'admin'::text)))));


--
-- Name: categories Authenticated users can delete categories.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can delete categories." ON public.categories FOR DELETE USING ((auth.role() = 'authenticated'::text));


--
-- Name: products Authenticated users can delete products.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can delete products." ON public.products FOR DELETE USING ((auth.role() = 'authenticated'::text));


--
-- Name: categories Authenticated users can insert categories.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can insert categories." ON public.categories FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text));


--
-- Name: products Authenticated users can insert products.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can insert products." ON public.products FOR INSERT WITH CHECK ((auth.role() = 'authenticated'::text));


--
-- Name: reviews Authenticated users can insert reviews.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can insert reviews." ON public.reviews FOR INSERT WITH CHECK (((auth.role() = 'authenticated'::text) AND (auth.uid() = user_id)));


--
-- Name: categories Authenticated users can update categories.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can update categories." ON public.categories FOR UPDATE USING ((auth.role() = 'authenticated'::text));


--
-- Name: products Authenticated users can update products.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can update products." ON public.products FOR UPDATE USING ((auth.role() = 'authenticated'::text));


--
-- Name: reviews Public approved reviews are viewable by everyone.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public approved reviews are viewable by everyone." ON public.reviews FOR SELECT USING ((is_approved = true));


--
-- Name: attributes Public attributes are viewable by everyone.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public attributes are viewable by everyone." ON public.attributes FOR SELECT USING (true);


--
-- Name: categories Public categories are viewable by everyone.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public categories are viewable by everyone." ON public.categories FOR SELECT USING (true);


--
-- Name: products Public products are viewable by everyone.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public products are viewable by everyone." ON public.products FOR SELECT USING (true);


--
-- Name: profiles Public profiles are viewable by everyone.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);


--
-- Name: product_variant_attributes Public variant attributes are viewable by everyone.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public variant attributes are viewable by everyone." ON public.product_variant_attributes FOR SELECT USING (true);


--
-- Name: product_variants Public variants are viewable by everyone.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Public variants are viewable by everyone." ON public.product_variants FOR SELECT USING (true);


--
-- Name: addresses Users can delete their own addresses.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete their own addresses." ON public.addresses FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: cart_items Users can delete their own cart items.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete their own cart items." ON public.cart_items FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: reviews Users can delete their own reviews.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete their own reviews." ON public.reviews FOR DELETE USING ((auth.uid() = user_id));


--
-- Name: addresses Users can insert their own addresses.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert their own addresses." ON public.addresses FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: cart_items Users can insert their own cart items.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert their own cart items." ON public.cart_items FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: order_items Users can insert their own order items.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert their own order items." ON public.order_items FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM public.orders
  WHERE ((orders.id = order_items.order_id) AND (orders.user_id = auth.uid())))));


--
-- Name: orders Users can insert their own orders.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert their own orders." ON public.orders FOR INSERT WITH CHECK ((auth.uid() = user_id));


--
-- Name: profiles Users can insert their own profile.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK ((auth.uid() = id));


--
-- Name: profiles Users can update own profile.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING ((auth.uid() = id));


--
-- Name: addresses Users can update their own addresses.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own addresses." ON public.addresses FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: cart_items Users can update their own cart items.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own cart items." ON public.cart_items FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: reviews Users can update their own reviews.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own reviews." ON public.reviews FOR UPDATE USING ((auth.uid() = user_id));


--
-- Name: addresses Users can view their own addresses.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own addresses." ON public.addresses FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: cart_items Users can view their own cart items.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own cart items." ON public.cart_items FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: order_items Users can view their own order items.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own order items." ON public.order_items FOR SELECT USING ((EXISTS ( SELECT 1
   FROM public.orders
  WHERE ((orders.id = order_items.order_id) AND (orders.user_id = auth.uid())))));


--
-- Name: orders Users can view their own orders.; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own orders." ON public.orders FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: reviews Users can view their own reviews (even if unapproved).; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own reviews (even if unapproved)." ON public.reviews FOR SELECT USING ((auth.uid() = user_id));


--
-- Name: addresses; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.addresses ENABLE ROW LEVEL SECURITY;

--
-- Name: attributes; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.attributes ENABLE ROW LEVEL SECURITY;

--
-- Name: cart_items; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.cart_items ENABLE ROW LEVEL SECURITY;

--
-- Name: categories; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

--
-- Name: order_items; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;

--
-- Name: product_variant_attributes; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.product_variant_attributes ENABLE ROW LEVEL SECURITY;

--
-- Name: product_variants; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.product_variants ENABLE ROW LEVEL SECURITY;

--
-- Name: products; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

--
-- Name: profiles; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

--
-- Name: reviews; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;



--
-- Name: reviews trigger_update_rating; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_rating AFTER INSERT OR DELETE OR UPDATE ON public.reviews FOR EACH ROW EXECUTE FUNCTION public.update_product_rating();

